1. Check and complete the pre/post conditions, particularly the finiteness of XPT, XOPT, STEP, X,
   etc.

2. Profile the Fortran code to find which subroutine costs the most time.
   We can use gprof and gprof2dot to to this:
   https://www.thegeekstuff.com/2012/08/gprof-tutorial/
   https://github.com/jrfonseca/gprof2dot
   $ gcc -pg main.f90
   $ gprof a.out gmon.out | gprof2dot | dot -Tpng -o output.png

3. 20230108: See TODO_mat

4. What about solving the TR subproblem of COBYLA using a composite step approach? Vardi or
   Byrd-Omojokun?

5. Check the definition and update of RESCON in LINCOA, in UPDATE/UPDATERES.

6. Unify the UPDATEQ, UPDATEXF(, and UPDATEH) of BOBYQA/LINCOA/NEWUOA.

7. Implement a subroutine that evaluates the functions, updates NF, updates history/filter, and
   prints messages?

9. Test whether the scaling threshold in the trust-region subproblem solvers can be improved.

10. For NEWUOA, BOBYQA, LINCOA, implement the trust-redundant subroutine solvers using hmul.
Update 20230301: This is not doable (cleanly) because we scale the data before starting the TR
calculation.

11. What about invoking RESCUE in the following way?

After a trust-region step, if the denominator is bad, set TO_RESCUE = .TRUE., but perform the
update as normal (if the denominator is 0 or NaN occurs, skip the update of H in UPDATEH).
Set IMPROVE_GEO and REDUCE_RHO to .FALSE. if TO_RESCUE is .TRUE. After a geometry step, set
TO_RESCUE to .TRUE. if the denominator is bad, but perform the update as normal. If TO_RESCUE is
.TRUE., invoke RESCUE, which can be regarded as a post-processing.

12. Implement IPRINT for MATLAB, essentially writing a MEX version of output.f90.

13. Change the macros in ppf.h to PRIMA_*.
