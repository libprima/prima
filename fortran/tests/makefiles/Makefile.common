# This Makefile tests the modern-Fortran version of Powell's solvers on multiple compilers.
#
# 1.  The following compilers are tested:
# 9: G95 (compilation only; no compilation of test_*.f90 and other testing code, which contains F03 constructs unsupported by G95)
# d: AOCC flang (based on Classic Flang)
# f: LLVM flang
# g: GNU gfortran
# m: AOMP flang (based on LLVM Flang)
# n: NAG nagfor
# i: Intel ifort
# r: Arm flang (based on LLVM Flang)
# s: Oracle sunf95
# v: NVIDIA nvfortran (based on Classic Flang)
# x: Intel ifx
#
# 2. The following tests are available, where C = 9, d, f, g, l, m, n, i, r, s, v, x, and N = 2, 4, 8:
# Ctest: test with compiler C
# Ctest_c: test with compiler C; compilation only (do not run the binary)
# Ctest_iN: test with compiler C and integer kind INT(N*8)
# Ctest_iN_c: test with compiler C and integer kind INT(N*8); compilation only
#
# 3. The compilation flags concerning optimization / debugging can be controlled by the environment
# variable FFLAGS, which may be set to empty, -g, -O, -Oi (i = 1, 2, 3), or -fast. If FFLAGS is
# empty, then we will test both an optimized version (compiled with -O3) and a debugging version
# (compiled with -g -O0); otherwise, a version indicated by FFLAGS will be tested.
#
# 4. `-Wl,-z,noexecstack` passes the `-z noexecstack` option to the linker and tells the linker to
# set the "stack is not executable" attribute in the output file. If executable stacks are actually
# needed, then it will lead to a runtime error. This is to test that our code does not require executable
# stacks, which is a security risk. COBYLA used to use an internal subroutine passed as an actual
# argument, which necessitates an executable stack with some compilers, but such code has been
# removed on 20250812. See git commit 5e5e871 and
# https://fortran-lang.discourse.group/t/implementation-of-a-parametrized-objective-function-without-using-module-variables-or-internal-subroutines
#
# 5. Do not miss the quotes around the command substitution for the compilers. This is to ensure
# that the path is resolved correctly if it contains spaces (very often on Windows).
#
#
# Coded by Zaikun ZHANG (www.zhangzk.net).
#
# Started: September 2021
#
# Last Modified: February 2026
####################################################################################################

#$(VERBOSE).SILENT:  # Order make to work quietly. Not desirable in this case.

SHELL = /usr/bin/env bash

####################################################################################################
# Variables

# Fortran standard to follow. We aim to make the code compatible with F2008 and above.
FS ?= 08
FSTD := 20$(FS)

# Default options for all the compilers, and corresponding suffixes for the executable. In general,
# "O" indicates optimization, and "G" means debugging.
FFLAGS ?= -g
FFLAGSO :=
FFLAGSG := -g -O0
SUFFIXO :=
SUFFIXG := g
AGGRESSIVE := 0
ifeq ($(FFLAGS),-O)
	FFLAGSO := $(FFLAGS)
	FFLAGSG :=
	SUFFIXO := o
	SUFFIXG :=
endif
ifeq ($(FFLAGS),-O1)
	FFLAGSO := $(FFLAGS)
	FFLAGSG :=
	SUFFIXO := o1
	SUFFIXG :=
endif
ifeq ($(FFLAGS),-O2)
	FFLAGSO := $(FFLAGS)
	FFLAGSG :=
	SUFFIXO := o2
	SUFFIXG :=
endif
ifeq ($(FFLAGS),-O3)
	FFLAGSO := $(FFLAGS)
	FFLAGSG :=
	SUFFIXO := o3
	SUFFIXG :=
endif
ifeq ($(FFLAGS),-fast)
	FFLAGSO := $(FFLAGS)
	FFLAGSG :=
	SUFFIXO := fast
	SUFFIXG :=
	AGGRESSIVE := 1
endif

# Define the compiler-dependent "fast flags", which will be used when FFLAGS is -fast.
AFF := -O4
DFF := -O3 -Ofast -ffast-math  # As of AOCC 5.1, -Ofast implies -O3, but it is not clear whether it implies -ffast-math; -O4 and -O3 are equivalent for AOCC 5.1
FFF := -O3 -ffast-math  # Suggested by flang 20.1.7
GFF := -Ofast  # -Ofast implies -O3 and -ffast-math
MFF := -O3 -ffast-math  # Suggested by AOMP 22.0-2 when running `amdflang --help | grep fast`, -Ofast is deprecated
NFF := -O4
RFF := -O3 -ffast-math  # '-Ofast' is deprecated; use '-O3 -ffast-math -fstack-arrays' for the same behavior
SFF := -fast # -fast implies -O5 and ftrap=common
SFF16 := -O5  # -fast leads to a mistakenly failure of assertion in BOBYQA: RHOBEG <= MINVAL(XU-XL)/2
VFF := -O4 -fast  # nvfortran -fast implies -O2, but the highest optimization level is -O4
9FF := -O4

# Define fast flags for Intel compilers according to the CPU brand.
# As of ifx (IFORT) 2022.2.1, -fast will lead to the following error on AMD CPUs:
# "LLVM ERROR: 64-bit code requested on a subtarget that doesn't support it!"
# For ifort (IFORT) 2021.7.1, -fast will lead to the following error on AMAD CPUs:
# catastrophic error: Function return parameter requires SSE register while SSE is disabled.
# In the following, we assume that there is only one type of CPU on the current platform.
ifneq (,$(findstring intel,$(shell lscpu 2> /dev/null | tr '[:upper:]' '[:lower:]')))  # Intel CPU.
	# According to
	# https://www.intel.com/content/www/us/en/docs/fortran-compiler/developer-guide-reference/2024-0/fast.html,
	# -fast sets the following options:
	# -ipo, -O3, -no-prec-div,-static, -fp-model fast=2, and -xHost
	# ifort -fast with ifort (IFORT) 2021.11.1 does not work due to an error with -ipo.
	IFF := -O3 -no-prec-div -static -fp-model fast=2 -xHost
	XFF := -fast  # -fast seems to work starting from ifx (IFX) 2024.0.0
else  # Non-Intel CPU, especially AMD.
	IFF := -Ofast # -Ofast implies -O3
	XFF := -Ofast -xHost
endif

TESTSEED ?=
TESTDIM ?= small

# Log file stamp.
RANDNUM := $(shell awk 'BEGIN{srand();printf("%d", 65536*rand())}')
TIME := $(shell date +%Y.%m.%d_%H.%M.%S)
STAMP := $(TIME)_$(RANDNUM)

# Test directory.
TEST_SOLVER_DIR := $(CURDIR)
TEST_DIR := $(TEST_SOLVER_DIR)/..
# Log directory.
LOG_DIR := $(TEST_SOLVER_DIR)/log
# Trash directory.
TRASH_DIR := $(TEST_SOLVER_DIR)/trash
# Common directory.
COMMON := common
COMMON_DIR := $(TEST_DIR)/../$(COMMON)
# Solver directory.
SOLVER_DIR := $(TEST_DIR)/../$(SOLVER)
# Test suite directory.
TESTSUITE := testsuite
TESTSUITE_DIR := $(TEST_DIR)/$(TESTSUITE)
# Source directories.
SRC_DIRS := $(COMMON_DIR) $(SOLVER_DIR) $(TESTSUITE_DIR)
# Driver directory.
DRIVER_DIR := $(TEST_DIR)
# Tools directory
TOOLS_DIR := $(TEST_DIR)/tools

# Sources.
COMMON_SRC := $(shell sed "s/^/\.\/common\//" $(COMMON_DIR)/ffiles.txt)
SOLVER_SRC := $(shell sed "s/^/\.\/$(SOLVER)\//" $(SOLVER_DIR)/ffiles.txt)
TESTSUITE_SRC := $(shell sed "s/^/\.\/$(TESTSUITE)\//" $(TESTSUITE_DIR)/ffiles.txt)
DRIVER_SRC := test_$(SOLVER).f90 test.F90
SRC := $(COMMON_SRC) $(SOLVER_SRC) $(TESTSUITE_SRC) $(DRIVER_SRC)
SRC_NO_TEST := $(COMMON_SRC) $(SOLVER_SRC)

# Headers.
# N.B.: If we define COMMON as "./common/", then, when adapting the header, sed will complain
# that"./common//*.h" cannot be found on macOS.
HEADERS := $(TEST_SOLVER_DIR)/$(COMMON)/*.h

# The checktest script.
CHCKTST := $(TOOLS_DIR)/checktest

# Define the tests.
######################################################################################
# Decide whether to test QP, i.e., REAL128.
# AOCC 5.1 Flang is buggy concerning `nint` with REAL128 (https://github.com/zequipe/test_compiler/blob/master/test_nint.f90)
# LLVM Flang 21.1.0 does not support REAL128.
# nvfortran 26.1 do not support REAL128;
TESTS_QP = gtest mtest ntest itest stest 9test xtest
TESTS_NO_QP = dtest ftest rtest vtest
TESTS = $(TESTS_QP) $(TESTS_NO_QP)
# When listing the tests, we first put the ones that are more likely to raise errors.
$(foreach TST, $(TESTS_QP), $(eval $(TST): SUBTESTS := \
	$(TST)_i2_r16_d1_tst $(TST)_i2_r4_d1_tst $(TST)_i2_r8_d1_tst \
	$(TST)_i4_r16_d1_tst $(TST)_i4_r4_d1_tst $(TST)_i4_r8_d1_tst \
	$(TST)_i8_r16_d1_tst $(TST)_i8_r4_d1_tst $(TST)_i8_r8_d1_tst \
	$(TST)_i2_r16_d0_tst $(TST)_i2_r4_d0_tst $(TST)_i2_r8_d0_tst \
	$(TST)_i4_r16_d0_tst $(TST)_i4_r4_d0_tst $(TST)_i4_r8_d0_tst \
	$(TST)_i8_r16_d0_tst $(TST)_i8_r4_d0_tst $(TST)_i8_r8_d0_tst \
	))
$(foreach TST, $(TESTS_NO_QP), $(eval $(TST): SUBTESTS := \
	$(TST)_i2_r4_d1_tst $(TST)_i2_r8_d1_tst \
	$(TST)_i4_r4_d1_tst $(TST)_i4_r8_d1_tst \
	$(TST)_i8_r4_d1_tst $(TST)_i8_r8_d1_tst \
	$(TST)_i2_r4_d0_tst $(TST)_i2_r8_d0_tst \
	$(TST)_i4_r4_d0_tst $(TST)_i4_r8_d0_tst \
	$(TST)_i8_r4_d0_tst $(TST)_i8_r8_d0_tst \
	))
$(foreach TST, $(TESTS), $(eval $(TST): TST_C := $(TST)_c))

# The following tests compile the code but do not run the binary. This is useful if we want to
# check whether the code can compile.
TESTS_C_QP = gtest_c mtest_c ntest_c itest_c stest_c 9test_c xtest_c
TESTS_C_NO_QP = dtest_c ftest_c rtest_c vtest_c
TESTS_C = $(TESTS_C_QP) $(TESTS_C_NO_QP)
$(foreach TST, $(TESTS_C_QP), $(eval $(TST): SUBTESTS_C := \
	$(subst _c,,$(TST))_i2_r16_d1_tst_c $(subst _c,,$(TST))_i2_r4_d1_tst_c $(subst _c,,$(TST))_i2_r8_d1_tst_c \
	$(subst _c,,$(TST))_i4_r16_d1_tst_c $(subst _c,,$(TST))_i4_r4_d1_tst_c $(subst _c,,$(TST))_i4_r8_d1_tst_c \
	$(subst _c,,$(TST))_i8_r16_d1_tst_c $(subst _c,,$(TST))_i8_r4_d1_tst_c $(subst _c,,$(TST))_i8_r8_d1_tst_c \
	$(subst _c,,$(TST))_i2_r16_d0_tst_c $(subst _c,,$(TST))_i2_r4_d0_tst_c $(subst _c,,$(TST))_i2_r8_d0_tst_c \
	$(subst _c,,$(TST))_i4_r16_d0_tst_c $(subst _c,,$(TST))_i4_r4_d0_tst_c $(subst _c,,$(TST))_i4_r8_d0_tst_c \
	$(subst _c,,$(TST))_i8_r16_d0_tst_c $(subst _c,,$(TST))_i8_r4_d0_tst_c $(subst _c,,$(TST))_i8_r8_d0_tst_c \
	))
$(foreach TST, $(TESTS_C_NO_QP), $(eval $(TST): SUBTESTS_C := \
	$(subst _c,,$(TST))_i2_r4_d1_tst_c $(subst _c,,$(TST))_i2_r8_d1_tst_c \
	$(subst _c,,$(TST))_i4_r4_d1_tst_c $(subst _c,,$(TST))_i4_r8_d1_tst_c \
	$(subst _c,,$(TST))_i8_r4_d1_tst_c $(subst _c,,$(TST))_i8_r8_d1_tst_c \
	$(subst _c,,$(TST))_i2_r4_d0_tst_c $(subst _c,,$(TST))_i2_r8_d0_tst_c \
	$(subst _c,,$(TST))_i4_r4_d0_tst_c $(subst _c,,$(TST))_i4_r8_d0_tst_c \
	$(subst _c,,$(TST))_i8_r4_d0_tst_c $(subst _c,,$(TST))_i8_r8_d0_tst_c \
	))

# The tests with ifort, ifx, etc are slow due to the extensive runtime checks. To save time, we
# define the following tests. If itest_i2 succeeds, then itest_i4 and itest_i8 are likely (but not
# surely) to be OK, because the only difference in the code is the integer kind. Similar for others.
TESTS_INT_QP = gtest_i2 gtest_i4 gtest_i8 \
			   mtest_i2 mtest_i4 mtest_i8 \
			   ntest_i2 ntest_i4 ntest_i8 \
			   itest_i2 itest_i4 itest_i8 \
			   stest_i2 stest_i4 stest_i8 \
			   9test_i2 9test_i4 9test_i8 \
			   xtest_i2 xtest_i4 xtest_i8
TESTS_INT_NO_QP = dtest_i2 dtest_i4 dtest_i8 \
				  ftest_i2 ftest_i4 ftest_i8 \
				  rtest_i2 rtest_i4 rtest_i8 \
				  vtest_i2 vtest_i4 vtest_i8
TESTS_INT = $(TESTS_INT_QP) $(TESTS_INT_NO_QP)
$(foreach TST, $(TESTS_INT_QP), $(eval $(TST): SUBTESTS := \
	$(TST)_r16_d1_tst $(TST)_r4_d1_tst $(TST)_r8_d1_tst \
	$(TST)_r16_d0_tst $(TST)_r4_d0_tst $(TST)_r8_d0_tst \
	))
$(foreach TST, $(TESTS_INT_NO_QP), $(eval $(TST): SUBTESTS := \
	$(TST)_r4_d1_tst $(TST)_r8_d1_tst \
	$(TST)_r4_d0_tst $(TST)_r8_d0_tst \
	))
$(foreach TST, $(TESTS_INT), $(eval $(TST): TST_C := $(TST)_c))

# The following tests compile the code but do not run the binary. This is useful if we want to
# check whether the code can compile.
TESTS_INT_C_QP = gtest_i2_c gtest_i4_c gtest_i8_c \
				 mtest_i2_c mtest_i4_c mtest_i8_c \
				 ntest_i2_c ntest_i4_c ntest_i8_c \
				 itest_i2_c itest_i4_c itest_i8_c \
				 stest_i2_c stest_i4_c stest_i8_c \
				 9test_i2_c 9test_i4_c 9test_i8_c \
			     xtest_i2_c xtest_i4_c xtest_i8_c
TESTS_INT_C_NO_QP = dtest_i2_c dtest_i4_c dtest_i8_c \
					ftest_i2_c ftest_i4_c ftest_i8_c \
					rtest_i2_c rtest_i4_c rtest_i8_c \
					vtest_i2_c vtest_i4_c vtest_i8_c
TESTS_INT_C = $(TESTS_INT_C_QP) $(TESTS_INT_C_NO_QP)
$(foreach TST, $(TESTS_INT_C_QP), $(eval $(TST): SUBTESTS_C := \
	$(subst _c,,$(TST))_r16_d1_tst_c $(subst _c,,$(TST))_r4_d1_tst_c $(subst _c,,$(TST))_r8_d1_tst_c \
	$(subst _c,,$(TST))_r16_d0_tst_c $(subst _c,,$(TST))_r4_d0_tst_c $(subst _c,,$(TST))_r8_d0_tst_c \
	))
$(foreach TST, $(TESTS_INT_C_NO_QP), $(eval $(TST): SUBTESTS_C := \
	$(subst _c,,$(TST))_r4_d1_tst_c $(subst _c,,$(TST))_r8_d1_tst_c \
	$(subst _c,,$(TST))_r4_d0_tst_c $(subst _c,,$(TST))_r8_d0_tst_c \
	))
######################################################################################

.PHONY: all test test_c clean $(TESTS) $(TESTS_C) $(TESTS_INT) $(TESTS_INT_C) source_* clean*

# Operating system.
# We assume the OS is LINUX by default.
OSTYPE := LINUX
ifeq ($(OS),Windows_NT)
	OSTYPE := WINDOWS
else
	UNAME_S := $(shell uname -s)
	ifeq ($(UNAME_S),Darwin)
		OSTYPE := MAC
	endif
	ifeq ($(UNAME_S),FreeBSD)
		OSTYPE := FREEBSD
	endif
	ifneq ($(shell grep -qi "alpine" /etc/os-release 2>/dev/null || echo ""),)
		OSTYPE := ALPINE
	endif
endif

# Invoke the binary by gdb using $(TOOLS_DIR)/run_gdb, which is a wrapper script. It does two
# things: 1) It runs the binary under gdb in the batch mode and the -return-child-result mode, so
# that the exit code of the binary is returned as the exit code of gdb. 2) If gdb fails (e.g., the
# binary crashes), it records the exit code of gdb in a specified file and exits successfully.
# In this way, the Makefile receipt can continue to call `checktest` to check the log file regardless
# of the failure. The exit code will be checked after the test by reading the aforementioned file.
# For more details, see $(TOOLS_DIR)/run_gdb.
ifeq ($(OSTYPE), MAC)
	# On GitHub Actions, gdb does not work out of the box due to security restrictions.
	GDB :=
else
	GDB := bash $(TOOLS_DIR)/run_gdb
endif

# Define SEDI.
# When calling "sed -i" on macOS, it is obligatory to specify a string (e.g., .bak) after -i as the
# extension for saving a backup. If the string is "", then no backup will be saved. If no string is
# specified, then an error will be raised, saying "invalid command code".
SEDI :=
ifeq ($(OSTYPE), MAC)
	SEDI := sed -i ""
else
	SEDI := sed -i
endif

# Define NPROCS to be the number of processors available to make tests in parallel.
NPROCS :=
ifeq ($(OSTYPE), LINUX)
	NPROCS := $(shell grep -c 'processor' /proc/cpuinfo 2>/dev/null || echo 1)
else ifeq ($(OSTYPE), MAC)
	NPROCS := $(shell sysctl hw.ncpu | grep -o '[0-9]\+' || echo 1)
else
	NPROCS := $(shell echo $(NUMBER_OF_PROCESSORS) || echo 1)
endif


####################################################################################################
# Here are the testing options for each compiler. We try to turn on as many debugging options as
# possible, in particular, the options regarding the following are included whenever available.
# 1. Standard conformity.
# 2. Runtime bound checking of arrays.
# 3. IEEE 754 Floating-Point Exceptions (FPE). Note the following.
# 1) We do not require compilers to produce code that complies with the IEEE 754 semantics, but
# leave them to handle floating point calculations in the default or fast way. In particular, we do
# not enforce options such as -fp-model strict (for ifort and ifx) or -Kieee (for flang).
# 2) Despite of 1), we instruct compilers to handle floating-point exceptions in a fairly strict way.
# In our development, we require that most FPEs should lead to an error that terminates the program,
# so that we can examine the exceptions and find ways to avoid them if possible.
# 3) Depending on the compiler, some FPEs are ignored for the tests with r4 (single-precision real),
# e.g., over/underflow.
####################################################################################################

# AMD AOCC Flang
AFLANG := "$(shell find -L /opt/AMD -type f -name flang -exec test -x {} \; -print 2>/dev/null | sort | tail -n 1)"
#AFINC := $(shell dirname $$(dirname $(AFLANG) 2>/dev/null) 2>/dev/null)/include
#AFLIB := $(shell dirname $$(dirname $(AFLANG) 2>/dev/null) 2>/dev/null)/lib
#AFLANG := $(AFLANG) -I$(AFINC) -L$(AFLIB)
DFORT := $(AFLANG) -pedantic-errors -Werror
ifeq ($(TESTDIM),small)
	DFORT := $(DFORT) -Mstack_arrays
else
	DFORT := $(DFORT) -fno-stack-arrays  # -Mnostack_arrays is not recognized by AOCC 5.1
endif
# Strangely, with `-Mchkptr`, the compiler may not print the error message of `-Mbounds` anymore.
DFORT := $(DFORT) -std=f$(FSTD) -pedantic -Weverything -Wall -Wextra -Minform=warn -Mstandard -Mbounds -Mrecursive #-Kieee #-Mchkptr
ifeq ($(OSTYPE),LINUX)
	DFORT := $(DFORT) -Wl,-z,noexecstack
endif

dtest_i2_r4_d1_tst_c dtest_i4_r4_d1_tst_c dtest_i8_r4_d1_tst_c dtest_i2_r4_d0_tst_c dtest_i4_r4_d0_tst_c dtest_i8_r4_d0_tst_c: \
	FCO := $(DFORT) $(FFLAGSO)
dtest_i2_r4_d1_tst_c dtest_i4_r4_d1_tst_c dtest_i8_r4_d1_tst_c dtest_i2_r4_d0_tst_c dtest_i4_r4_d0_tst_c dtest_i8_r4_d0_tst_c: \
	FCG := $(DFORT) $(FFLAGSG)
dtest_i2_r4_d1_tst_c dtest_i4_r4_d1_tst_c dtest_i8_r4_d1_tst_c dtest_i2_r4_d0_tst_c dtest_i4_r4_d0_tst_c dtest_i8_r4_d0_tst_c: \
	FCF := $(DFORT) $(DFF)

dtest_i2_r8_d1_tst_c dtest_i4_r8_d1_tst_c dtest_i8_r8_d1_tst_c dtest_i2_r8_d0_tst_c dtest_i4_r8_d0_tst_c dtest_i8_r8_d0_tst_c: \
	FCO := $(DFORT) $(FFLAGSO) -ffp-exception-behavior=strict
dtest_i2_r8_d1_tst_c dtest_i4_r8_d1_tst_c dtest_i8_r8_d1_tst_c dtest_i2_r8_d0_tst_c dtest_i4_r8_d0_tst_c dtest_i8_r8_d0_tst_c: \
	FCG := $(DFORT) $(FFLAGSG) -ffp-exception-behavior=strict
dtest_i2_r8_d1_tst_c dtest_i4_r8_d1_tst_c dtest_i8_r8_d1_tst_c dtest_i2_r8_d0_tst_c dtest_i4_r8_d0_tst_c dtest_i8_r8_d0_tst_c: \
	FCF := $(DFORT) -ffp-exception-behavior=strict $(DFF)

dtest_i2_r16_d1_tst_c dtest_i4_r16_d1_tst_c dtest_i8_r16_d1_tst_c dtest_i2_r16_d0_tst_c dtest_i4_r16_d0_tst_c dtest_i8_r16_d0_tst_c: \
	FCO := $(DFORT) $(FFLAGSO) -ffp-exception-behavior=strict
dtest_i2_r16_d1_tst_c dtest_i4_r16_d1_tst_c dtest_i8_r16_d1_tst_c dtest_i2_r16_d0_tst_c dtest_i4_r16_d0_tst_c dtest_i8_r16_d0_tst_c: \
	FCG := $(DFORT) $(FFLAGSG) -ffp-exception-behavior=strict
dtest_i2_r16_d1_tst_c dtest_i4_r16_d1_tst_c dtest_i8_r16_d1_tst_c dtest_i2_r16_d0_tst_c dtest_i4_r16_d0_tst_c dtest_i8_r16_d0_tst_c: \
	FCF := $(DFORT) -ffp-exception-behavior=strict $(DFF)

# AMD AOMP Flang
MFORT := "$(shell command -v amdflang)"
MFORT := $(MFORT) -fimplicit-none -Werror
ifeq ($(TESTDIM),small)
	MFORT := $(MFORT) -fstack-arrays
else
	MFORT := $(MFORT) -fno-stack-arrays -mmlir -fdynamic-heap-array
    # See https://github.com/llvm/llvm-project/issues/88344
endif
MFORT := $(MFORT) -std=f2018 -pedantic  # As of flang 20.0, only -std=f2018 is supported
ifeq ($(OSTYPE),LINUX)
	MFORT := $(MFORT) -Wl,-z,noexecstack
endif

mtest_i2_r4_d1_tst_c mtest_i4_r4_d1_tst_c mtest_i8_r4_d1_tst_c mtest_i2_r4_d0_tst_c mtest_i4_r4_d0_tst_c mtest_i8_r4_d0_tst_c: \
	FCO := $(MFORT) $(FFLAGSO)
mtest_i2_r4_d1_tst_c mtest_i4_r4_d1_tst_c mtest_i8_r4_d1_tst_c mtest_i2_r4_d0_tst_c mtest_i4_r4_d0_tst_c mtest_i8_r4_d0_tst_c: \
	FCG := $(MFORT) $(FFLAGSG)
mtest_i2_r4_d1_tst_c mtest_i4_r4_d1_tst_c mtest_i8_r4_d1_tst_c mtest_i2_r4_d0_tst_c mtest_i4_r4_d0_tst_c mtest_i8_r4_d0_tst_c: \
	FCF := $(MFORT) $(MFF)

mtest_i2_r8_d1_tst_c mtest_i4_r8_d1_tst_c mtest_i8_r8_d1_tst_c mtest_i2_r8_d0_tst_c mtest_i4_r8_d0_tst_c mtest_i8_r8_d0_tst_c: \
	FCO := $(MFORT) $(FFLAGSO)
mtest_i2_r8_d1_tst_c mtest_i4_r8_d1_tst_c mtest_i8_r8_d1_tst_c mtest_i2_r8_d0_tst_c mtest_i4_r8_d0_tst_c mtest_i8_r8_d0_tst_c: \
	FCG := $(MFORT) $(FFLAGSG)
mtest_i2_r8_d1_tst_c mtest_i4_r8_d1_tst_c mtest_i8_r8_d1_tst_c mtest_i2_r8_d0_tst_c mtest_i4_r8_d0_tst_c mtest_i8_r8_d0_tst_c: \
	FCF := $(MFORT) $(MFF)

mtest_i2_r16_d1_tst_c mtest_i4_r16_d1_tst_c mtest_i8_r16_d1_tst_c mtest_i2_r16_d0_tst_c mtest_i4_r16_d0_tst_c mtest_i8_r16_d0_tst_c: \
	FCO := $(MFORT) $(FFLAGSO)
mtest_i2_r16_d1_tst_c mtest_i4_r16_d1_tst_c mtest_i8_r16_d1_tst_c mtest_i2_r16_d0_tst_c mtest_i4_r16_d0_tst_c mtest_i8_r16_d0_tst_c: \
	FCG := $(MFORT) $(FFLAGSG)
mtest_i2_r16_d1_tst_c mtest_i4_r16_d1_tst_c mtest_i8_r16_d1_tst_c mtest_i2_r16_d0_tst_c mtest_i4_r16_d0_tst_c mtest_i8_r16_d0_tst_c: \
	FCF := $(MFORT) $(MFF)

# LLVM Flang
# Note that AOMP and AOCC also provide "flang". We define FFORT as follows to make sure the correct
# one is being called. Otherwise, flang may be resolved to the one provided by AOMP or AOCC, which
# did happen in our tests.
FFORT := "$(shell find -L /usr/lib/llvm* /opt/homebrew /usr/local/opt /usr/local/Cellar -type f -name flang -exec test -x {} \; -print 2>/dev/null | sort | tail -n 1)"
# On Windows, the above command will fail to find flang and we set FFORT manually.
ifeq ($(OS),Windows_NT)
	FFORT := "$(shell command -v flang)"
endif
FFORT := $(FFORT) -fimplicit-none -Werror

ifeq ($(TESTDIM),small)
	FFORT := $(FFORT) -fstack-arrays
else
	FFORT := $(FFORT) -fno-stack-arrays -mmlir -fdynamic-heap-array
    # See https://github.com/llvm/llvm-project/issues/88344
endif
FFORT := $(FFORT) -std=f2018 -pedantic  # As of flang 20.0, only -std=f2018 is supported
ifeq ($(OSTYPE),LINUX)
	FFORT := $(FFORT) -Wl,-z,noexecstack
endif
ifeq ($(OSTYPE), MAC)
	SDKROOT := $(shell /usr/bin/xcrun --show-sdk-path -sdk macosx)
	FFORT := $(FFORT) -lSystem -L$(SDKROOT)/usr/lib
endif

ftest_i2_r4_d1_tst_c ftest_i4_r4_d1_tst_c ftest_i8_r4_d1_tst_c ftest_i2_r4_d0_tst_c ftest_i4_r4_d0_tst_c ftest_i8_r4_d0_tst_c: \
	FCO := $(FFORT) $(FFLAGSO)
ftest_i2_r4_d1_tst_c ftest_i4_r4_d1_tst_c ftest_i8_r4_d1_tst_c ftest_i2_r4_d0_tst_c ftest_i4_r4_d0_tst_c ftest_i8_r4_d0_tst_c: \
	FCG := $(FFORT) $(FFLAGSG)
ftest_i2_r4_d1_tst_c ftest_i4_r4_d1_tst_c ftest_i8_r4_d1_tst_c ftest_i2_r4_d0_tst_c ftest_i4_r4_d0_tst_c ftest_i8_r4_d0_tst_c: \
	FCF := $(FFORT) $(FFF)

ftest_i2_r8_d1_tst_c ftest_i4_r8_d1_tst_c ftest_i8_r8_d1_tst_c ftest_i2_r8_d0_tst_c ftest_i4_r8_d0_tst_c ftest_i8_r8_d0_tst_c: \
	FCO := $(FFORT) $(FFLAGSO)
ftest_i2_r8_d1_tst_c ftest_i4_r8_d1_tst_c ftest_i8_r8_d1_tst_c ftest_i2_r8_d0_tst_c ftest_i4_r8_d0_tst_c ftest_i8_r8_d0_tst_c: \
	FCG := $(FFORT) $(FFLAGSG)
ftest_i2_r8_d1_tst_c ftest_i4_r8_d1_tst_c ftest_i8_r8_d1_tst_c ftest_i2_r8_d0_tst_c ftest_i4_r8_d0_tst_c ftest_i8_r8_d0_tst_c: \
	FCF := $(FFORT) $(FFF)

ftest_i2_r16_d1_tst_c ftest_i4_r16_d1_tst_c ftest_i8_r16_d1_tst_c ftest_i2_r16_d0_tst_c ftest_i4_r16_d0_tst_c ftest_i8_r16_d0_tst_c: \
	FCO := $(FFORT) $(FFLAGSO)
ftest_i2_r16_d1_tst_c ftest_i4_r16_d1_tst_c ftest_i8_r16_d1_tst_c ftest_i2_r16_d0_tst_c ftest_i4_r16_d0_tst_c ftest_i8_r16_d0_tst_c: \
	FCG := $(FFORT) $(FFLAGSG)
ftest_i2_r16_d1_tst_c ftest_i4_r16_d1_tst_c ftest_i8_r16_d1_tst_c ftest_i2_r16_d0_tst_c ftest_i4_r16_d0_tst_c ftest_i8_r16_d0_tst_c: \
	FCF := $(FFORT) $(FFF)

# GNU gfortran
# 0. With std=f2008, gfortran complains that the stop-code of `error stop` "must be a scalar default
# CHARACTER or INTEGER constant expression". Thus we revise FSTD to f2018 or above. However, -std=f2018
# is recognized by gfortran 9 or above. So we remove -std=f2018 if the compiler is gfortran 7 or below.
# 1. In the debug mode, our code includes the BACKTRACE function if the compiler is gfortran. This
# makes the code not standard-conforming. So -std=f$(FSTD) cannot be imposed without -fall-intrinsics.
# 2. As of 2022, -Wextra implies -Wcompare-reals, -Wunused-parameter, and -Wdo-subscript.
# 3. Do not write [[ $(FS) -lt 18 ]], which will not work if FS is 08. This is because constants
# with a leading 0 are interpreted as octal (base-8) numbers within double brackets.
# see https://stackoverflow.com/questions/24777597/value-too-great-for-base-error-token-is-08
#GFORT := gfortran -pg  # Compile for profiling with the gprof profiler. Does not work with macOS on GitHub Actions due to missing gcrt1.o
GFORT := "$(shell command -v gfortran)"
GFSTD := $(shell  [[ $$(($(GFORT) -dumpversion 2>/dev/null || echo 0) | sed 's|\..*||') -gt 8 ]] && ([ $(FS) -lt 18 ] && echo -std=f2018 || echo -std=f20$(FS)) || echo "")
# 1. gfortran 7 raises a false positive warning regarding "maybe-uninitialized" of allocatable arrays.
# See https://stackoverflow.com/questions/56261880/fortran-re-allocation-on-assignment-and-gfortran-warnings
# 2. As of gfortran 11, gfortran raises a false positive warning regarding "maybe-uninitialized" of
# allocatable characters. See
# https://fortran-lang.discourse.group/t/warning-str-may-be-used-uninitialized
WE := $(shell if [[ $$(($(GFORT) -dumpversion 2>/dev/null || echo 0) | sed 's|\..*||') -gt 11 || $$(($(GFORT) -dumpversion 2>/dev/null || echo 0) | sed 's|\..*||') -gt 8 && -z '$(FFLAGSG)' ]] ; then echo "-Werror"; else echo ""; fi)
# gfortran 14 has a bug when it is called with `gfortran -Wmaybe-uninitialized -fsanitize=undefined -Ok`,
# where k is 2, 3, 4, or fast. See
# https://fortran-lang.discourse.group/t/gfortran-14-mem-real-kind-4-0-real-kind-4-0-32-0-may-be-used-uninitialized
WU := $(shell if [[ $$(($(GFORT) -dumpversion 2>/dev/null || echo 0) | sed 's|\..*||') -gt 13 && "$(FFLAGS)" != "-g" && "$(FFLAGS)" != "-O" && "$(FFLAGS)" != "-O1" ]] ; then echo "-Wno-uninitialized"; else echo "-Wuninitialized -Wmaybe-uninitialized"; fi)
# gfortran 14+ supports the `-ftrampoline-impl=heap` option, which is needed to avoid the
# warning about executable stacks caused by internal procedures passed as arguments. See
# https://fortran-lang.discourse.group/t/implementation-of-a-parametrized-objective-function-without-using-module-variables-or-internal-subroutines
TRAMPOLINE := $(shell  [[ $$(($(GFORT) -dumpversion 2>/dev/null || echo 0) | sed 's|\..*||') -gt 13 ]] && (echo "-ftrampoline-impl=heap") || echo "")
GFORT := $(GFORT) $(WE) $(TRAMPOLINE) -pedantic-errors -fmax-errors=1
# `-fautomatic` (the default) tells `gfortran` to use the stack for local variables smaller than the
# value given by -fmax-stack-var-size. `-fstack-arrays` forces all automatic arrays to be on the stack.
# We enable them for small problems to verify that we will not have stack overflows.
# N.B.: -Ofast turns on -fstack-arrays. We have to turn if off when the problem is big.
ifeq ($(TESTDIM),small)
	GFORT := $(GFORT) -fautomatic -fstack-check #-fstack-arrays  # Strangely, -fstack-arrays will hide some warnings on uninitialized variables.
else
	GFORT := $(GFORT) -fno-stack-arrays -fstack-check
endif
# -fsanitize=leak,address does not work with gdb.
FSAN := $(shell if [[ $$(($(GFORT) -dumpversion 2>/dev/null || echo 0) | sed 's|\..*||') -gt 9 && $(OSTYPE) == 'LINUX' ]] ; then echo "-fsanitize=undefined"; else echo ""; fi)
GFORT := $(GFORT) $(GFSTD) -fall-intrinsics -frecursive \
	-Wall -Wextra -Wpedantic -pedantic -Wampersand -Wconversion \
	-Wsurprising -Waliasing -Wimplicit-interface -Wimplicit-procedure -Wintrinsics-std -Wunderflow \
	-Wuse-without-only -Wunused-parameter -Wreturn-type \
	$(WU) \
	$(FSAN) \
	-fPIC -fimplicit-none -fbacktrace -fcheck=all \
	-ftrapv
	#-finit-real=nan -finit-integer=-9999999  # This will hide some warnings on uninitialized variables.
	#-Wrealloc-lhs -Wrealloc-lhs-all
ifeq ($(OSTYPE),LINUX)
	GFORT := $(GFORT) -Wl,-z,noexecstack
endif

gtest_i2_r4_d1_tst_c gtest_i4_r4_d1_tst_c gtest_i8_r4_d1_tst_c gtest_i2_r4_d0_tst_c gtest_i4_r4_d0_tst_c gtest_i8_r4_d0_tst_c: \
	FCO := $(GFORT) $(FFLAGSO) -Wno-function-elimination -ffpe-trap=zero
gtest_i2_r4_d1_tst_c gtest_i4_r4_d1_tst_c gtest_i8_r4_d1_tst_c gtest_i2_r4_d0_tst_c gtest_i4_r4_d0_tst_c gtest_i8_r4_d0_tst_c: \
	FCG := $(GFORT) $(FFLAGSG) -ffpe-trap=zero
gtest_i2_r4_d1_tst_c gtest_i4_r4_d1_tst_c gtest_i8_r4_d1_tst_c gtest_i2_r4_d0_tst_c gtest_i4_r4_d0_tst_c gtest_i8_r4_d0_tst_c: \
	FCF := $(GFORT) -Wno-function-elimination -ffpe-trap=zero $(GFF)

gtest_i2_r8_d1_tst_c gtest_i4_r8_d1_tst_c gtest_i8_r8_d1_tst_c gtest_i2_r8_d0_tst_c gtest_i4_r8_d0_tst_c gtest_i8_r8_d0_tst_c: \
	FCO := $(GFORT) $(FFLAGSO) -Wno-function-elimination -ffpe-trap=zero,overflow,invalid#,underflow,denorm
gtest_i2_r8_d1_tst_c gtest_i4_r8_d1_tst_c gtest_i8_r8_d1_tst_c gtest_i2_r8_d0_tst_c gtest_i4_r8_d0_tst_c gtest_i8_r8_d0_tst_c: \
	FCG := $(GFORT) $(FFLAGSG) -ffpe-trap=zero,overflow,invalid#,underflow,denorm
gtest_i2_r8_d1_tst_c gtest_i4_r8_d1_tst_c gtest_i8_r8_d1_tst_c gtest_i2_r8_d0_tst_c gtest_i4_r8_d0_tst_c gtest_i8_r8_d0_tst_c: \
	FCF := $(GFORT) -Wno-function-elimination -ffpe-trap=zero,invalid $(GFF)

gtest_i2_r16_d1_tst_c gtest_i4_r16_d1_tst_c gtest_i8_r16_d1_tst_c gtest_i2_r16_d0_tst_c gtest_i4_r16_d0_tst_c gtest_i8_r16_d0_tst_c: \
	FCO := $(GFORT) $(FFLAGSO) -Wno-function-elimination -ffpe-trap=zero,overflow,invalid#,underflow,denorm
gtest_i2_r16_d1_tst_c gtest_i4_r16_d1_tst_c gtest_i8_r16_d1_tst_c gtest_i2_r16_d0_tst_c gtest_i4_r16_d0_tst_c gtest_i8_r16_d0_tst_c: \
	FCG := $(GFORT) $(FFLAGSG) -ffpe-trap=zero,overflow,invalid#,underflow,denorm
gtest_i2_r16_d1_tst_c gtest_i4_r16_d1_tst_c gtest_i8_r16_d1_tst_c gtest_i2_r16_d0_tst_c gtest_i4_r16_d0_tst_c gtest_i8_r16_d0_tst_c: \
	FCF := $(GFORT) -Wno-function-elimination -ffpe-trap=zero,invalid $(GFF)

# Intel ifort
# -standard-semantics: enforce the compiler to behave according to the current standard (F2018 as of June 2023).
# See https://www.intel.com/content/www/us/en/develop/documentation/fortran-compiler-oneapi-dev-guide-and-reference/top/compiler-reference/compiler-options/compiler-option-details/language-options/standard-semantics.html
# Option standard-semantics enables option fpscomp logicals and the following settings for option
# assume: byterecl, failed_images, fpe_summary, ieee_compares, ieee_fpe_flags (if the fp-model
# option setting is strict or precise), minus0, nan_compares, noold_inquire_recl,
# noold_ldout_format, noold_ldout_zero, noold_maxminloc, noold_unit_star, noold_xor,
# protect_parens, realloc_lhs1, recursion, std_intent_in, std_minus0_rounding1, std_mod_proc_name,
# and std_value1.
IFORT := "$(shell command -v ifort)"
IFORT := $(IFORT) -diag-disable=10448  # Ignore the warning about the deprecation of ifort
IFORT := $(IFORT) -warn all -debug extended -warn errors -traceback -debug-parameters all #-diag-error-limit 1
# `-auto` causes all local, non-SAVEd variables to be allocated to the run-time stack.
# `-no-heap-arrays`, which is the default for `ifort`, causes the compiler puts automatic arrays
# and temporary arrays in the stack storage area. We enable them for small problems to verify that
# we will not have stack overflows even in the worst case.
# About -fp-stack-check: According to Steve Lionel (Dr. Fortran), "drop -fp-stack-check - that does
# nothing useful for you (it is for pre-SSE x87 32-bit code.)".
ifeq ($(TESTDIM),small)
	IFORT := $(IFORT) -auto -no-heap-arrays
else
	IFORT := $(IFORT) -auto -heap-arrays
endif
IFORT := $(IFORT) -standard-semantics -assume recursion
ifeq ($(OSTYPE),LINUX)
	IFORT := $(IFORT) -Wl,-z,noexecstack
endif

itest_i2_r4_d1_tst_c itest_i4_r4_d1_tst_c itest_i8_r4_d1_tst_c itest_i2_r4_d0_tst_c itest_i4_r4_d0_tst_c itest_i8_r4_d0_tst_c: \
	FCO := $(IFORT) $(FFLAGSO)
itest_i2_r4_d1_tst_c itest_i4_r4_d1_tst_c itest_i8_r4_d1_tst_c itest_i2_r4_d0_tst_c itest_i4_r4_d0_tst_c itest_i8_r4_d0_tst_c: \
	FCG := $(IFORT) $(FFLAGSG) -check all
itest_i2_r4_d1_tst_c itest_i4_r4_d1_tst_c itest_i8_r4_d1_tst_c itest_i2_r4_d0_tst_c itest_i4_r4_d0_tst_c itest_i8_r4_d0_tst_c: \
	FCF := $(IFORT) $(IFF)

itest_i2_r8_d1_tst_c itest_i4_r8_d1_tst_c itest_i8_r8_d1_tst_c itest_i2_r8_d0_tst_c itest_i4_r8_d0_tst_c itest_i8_r8_d0_tst_c: \
	FCO := $(IFORT) $(FFLAGSO) -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags
itest_i2_r8_d1_tst_c itest_i4_r8_d1_tst_c itest_i8_r8_d1_tst_c itest_i2_r8_d0_tst_c itest_i4_r8_d0_tst_c itest_i8_r8_d0_tst_c: \
	FCG := $(IFORT) $(FFLAGSG) -check all -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags
itest_i2_r8_d1_tst_c itest_i4_r8_d1_tst_c itest_i8_r8_d1_tst_c itest_i2_r8_d0_tst_c itest_i4_r8_d0_tst_c itest_i8_r8_d0_tst_c: \
	FCF := $(IFORT) -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags $(IFF)

itest_i2_r16_d1_tst_c itest_i4_r16_d1_tst_c itest_i8_r16_d1_tst_c itest_i2_r16_d0_tst_c itest_i4_r16_d0_tst_c itest_i8_r16_d0_tst_c: \
	FCO := $(IFORT) $(FFLAGSO) -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags
itest_i2_r16_d1_tst_c itest_i4_r16_d1_tst_c itest_i8_r16_d1_tst_c itest_i2_r16_d0_tst_c itest_i4_r16_d0_tst_c itest_i8_r16_d0_tst_c: \
	FCG := $(IFORT) $(FFLAGSG) -check all -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags
itest_i2_r16_d1_tst_c itest_i4_r16_d1_tst_c itest_i8_r16_d1_tst_c itest_i2_r16_d0_tst_c itest_i4_r16_d0_tst_c itest_i8_r16_d0_tst_c: \
	FCF := $(IFORT) -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags $(IFF)


# NAG nagfor
# In massive tests, we skip the useful -mtrace option (print memory allocation trace), as its output is enormous.
# It is necessary to use "-I$(TESTSUITE_DIR)"; otherwise, the INCLUDE lines in the test suite will not work.
NFORT := "$(shell command -v nagfor)"
NFORT := $(NFORT) -fpp  # As of nagfor 7.1, -fpp is needed on macOS and Windows, but not on Linux.
NFORT := $(NFORT) -I$(TESTSUITE_DIR)
NFORT := $(NFORT) -colour=error:red,warn:magenta,info:cyan
NFORT := $(NFORT) -f$(FSTD) -recursive -info -gline -u -C -C=alias -C=dangling -C=intovf -C=undefined -kind=unique \
	-Warn=constant_coindexing -Warn=subnormal #-Warn=allocation
ifeq ($(OSTYPE),LINUX)
	NFORT := $(NFORT) -Wl,-z,noexecstack
endif

ntest_i2_r4_d1_tst_c ntest_i4_r4_d1_tst_c ntest_i8_r4_d1_tst_c ntest_i2_r4_d0_tst_c ntest_i4_r4_d0_tst_c ntest_i8_r4_d0_tst_c: \
	FCO := $(NFORT) $(FFLAGSO) -nan -ieee=full
ntest_i2_r4_d1_tst_c ntest_i4_r4_d1_tst_c ntest_i8_r4_d1_tst_c ntest_i2_r4_d0_tst_c ntest_i4_r4_d0_tst_c ntest_i8_r4_d0_tst_c: \
	FCG := $(NFORT) $(FFLAGSG) -nan -ieee=full
ntest_i2_r4_d1_tst_c ntest_i4_r4_d1_tst_c ntest_i8_r4_d1_tst_c ntest_i2_r4_d0_tst_c ntest_i4_r4_d0_tst_c ntest_i8_r4_d0_tst_c: \
	FCF := $(NFORT) -nan -ieee=full $(NFF)

ntest_i2_r8_d1_tst_c ntest_i4_r8_d1_tst_c ntest_i8_r8_d1_tst_c ntest_i2_r8_d0_tst_c ntest_i4_r8_d0_tst_c ntest_i8_r8_d0_tst_c: \
	FCO := $(NFORT) $(FFLAGSO) -nan -ieee=stop
ntest_i2_r8_d1_tst_c ntest_i4_r8_d1_tst_c ntest_i8_r8_d1_tst_c ntest_i2_r8_d0_tst_c ntest_i4_r8_d0_tst_c ntest_i8_r8_d0_tst_c: \
	FCG := $(NFORT) $(FFLAGSG) -nan -ieee=stop
ntest_i2_r8_d1_tst_c ntest_i4_r8_d1_tst_c ntest_i8_r8_d1_tst_c ntest_i2_r8_d0_tst_c ntest_i4_r8_d0_tst_c ntest_i8_r8_d0_tst_c: \
	FCF := $(NFORT) -nan -ieee=stop $(NFF)

ntest_i2_r16_d1_tst_c ntest_i4_r16_d1_tst_c ntest_i8_r16_d1_tst_c ntest_i2_r16_d0_tst_c ntest_i4_r16_d0_tst_c ntest_i8_r16_d0_tst_c: \
	FCO := $(NFORT) $(FFLAGSO) -nan -ieee=stop
ntest_i2_r16_d1_tst_c ntest_i4_r16_d1_tst_c ntest_i8_r16_d1_tst_c ntest_i2_r16_d0_tst_c ntest_i4_r16_d0_tst_c ntest_i8_r16_d0_tst_c: \
	FCG := $(NFORT) $(FFLAGSG) -nan -ieee=stop
ntest_i2_r16_d1_tst_c ntest_i4_r16_d1_tst_c ntest_i8_r16_d1_tst_c ntest_i2_r16_d0_tst_c ntest_i4_r16_d0_tst_c ntest_i8_r16_d0_tst_c: \
	FCF := $(NFORT) -nan -ieee=stop $(NFF)

# NVIDIA nvfortran
VFORT := "$(shell command -v nvfortran)"
VFORT := $(VFORT) -Werror
# For nvfortran, -Mstack_arrays places automatic arrays on the stack. -Mnostack_arrays allocates
# automatic arrays on the heap. -Mnostack_arrays is the default.
ifeq ($(TESTDIM),small)
	VFORT := $(VFORT) -Mstack_arrays
else
	VFORT := $(VFORT) -Mnostack_arrays
endif
VFORT := $(VFORT) -C -Wall -Wextra -Minform=warn -Mstandard -Mrecursive -Mbounds -Mchkstk -Mchkptr -traceback
ifeq ($(OSTYPE),LINUX)
	VFORT := $(VFORT) -Wl,-z,noexecstack
endif

vtest_i2_r4_d1_tst_c vtest_i4_r4_d1_tst_c vtest_i8_r4_d1_tst_c vtest_i2_r4_d0_tst_c vtest_i4_r4_d0_tst_c vtest_i8_r4_d0_tst_c: \
	FCO := $(VFORT) $(FFLAGSO) #-Ktrap=divz #-Kieee
vtest_i2_r4_d1_tst_c vtest_i4_r4_d1_tst_c vtest_i8_r4_d1_tst_c vtest_i2_r4_d0_tst_c vtest_i4_r4_d0_tst_c vtest_i8_r4_d0_tst_c: \
	FCG := $(VFORT) $(FFLAGSG) #-Ktrap=divz #-Kieee
vtest_i2_r4_d1_tst_c vtest_i4_r4_d1_tst_c vtest_i8_r4_d1_tst_c vtest_i2_r4_d0_tst_c vtest_i4_r4_d0_tst_c vtest_i8_r4_d0_tst_c: \
	FCF := $(VFORT) $(VFF)

vtest_i2_r8_d1_tst_c vtest_i4_r8_d1_tst_c vtest_i8_r8_d1_tst_c vtest_i2_r8_d0_tst_c vtest_i4_r8_d0_tst_c vtest_i8_r8_d0_tst_c: \
	FCO := $(VFORT) $(FFLAGSO) -Ktrap=divz#,inv#,ovf,unf,denorm -Kieee
vtest_i2_r8_d1_tst_c vtest_i4_r8_d1_tst_c vtest_i8_r8_d1_tst_c vtest_i2_r8_d0_tst_c vtest_i4_r8_d0_tst_c vtest_i8_r8_d0_tst_c: \
	FCG := $(VFORT) $(FFLAGSG) -Ktrap=divz#,inv#,ovf,unf,denorm -Kieee
vtest_i2_r8_d1_tst_c vtest_i4_r8_d1_tst_c vtest_i8_r8_d1_tst_c vtest_i2_r8_d0_tst_c vtest_i4_r8_d0_tst_c vtest_i8_r8_d0_tst_c: \
	FCF := $(VFORT) $(VFF) #-Ktrap=inv $(VFF)

vtest_i2_r16_d1_tst_c vtest_i4_r16_d1_tst_c vtest_i8_r16_d1_tst_c vtest_i2_r16_d0_tst_c vtest_i4_r16_d0_tst_c vtest_i8_r16_d0_tst_c: \
	FCO := $(VFORT) $(FFLAGSO) -Ktrap=divz,ovf,inv#,unf,denorm -Kieee
vtest_i2_r16_d1_tst_c vtest_i4_r16_d1_tst_c vtest_i8_r16_d1_tst_c vtest_i2_r16_d0_tst_c vtest_i4_r16_d0_tst_c vtest_i8_r16_d0_tst_c: \
	FCG := $(VFORT) $(FFLAGSG) -Ktrap=divz,ovf,inv#,unf,denorm -Kieee
vtest_i2_r16_d1_tst_c vtest_i4_r16_d1_tst_c vtest_i8_r16_d1_tst_c vtest_i2_r16_d0_tst_c vtest_i4_r16_d0_tst_c vtest_i8_r16_d0_tst_c: \
	FCF := $(VFORT) -Ktrap=divz,ovf,inv $(VFF)


# Arm Flang
RFORT := "$(shell command -v armflang)"
ifeq ($(TESTDIM),small)
	RFORT := $(RFORT) -fstack-arrays
else
	RFORT := $(RFORT) -fno-stack-arrays -mmlir -fdynamic-heap-array
endif
RFORT := $(RFORT) -std=f2018 -pedantic -Wall  # As of 21.1, only f2018 is supported.
ifeq ($(OSTYPE),LINUX)
	RFORT := $(RFORT) -Wl,-z,noexecstack
endif

rtest_i2_r4_d1_tst_c rtest_i4_r4_d1_tst_c rtest_i8_r4_d1_tst_c rtest_i2_r4_d0_tst_c rtest_i4_r4_d0_tst_c rtest_i8_r4_d0_tst_c: \
	FCO := $(RFORT) $(FFLAGSO)
rtest_i2_r4_d1_tst_c rtest_i4_r4_d1_tst_c rtest_i8_r4_d1_tst_c rtest_i2_r4_d0_tst_c rtest_i4_r4_d0_tst_c rtest_i8_r4_d0_tst_c: \
	FCG := $(RFORT) $(FFLAGSG)
rtest_i2_r4_d1_tst_c rtest_i4_r4_d1_tst_c rtest_i8_r4_d1_tst_c rtest_i2_r4_d0_tst_c rtest_i4_r4_d0_tst_c rtest_i8_r4_d0_tst_c: \
	FCF := $(RFORT) $(RFF)

rtest_i2_r8_d1_tst_c rtest_i4_r8_d1_tst_c rtest_i8_r8_d1_tst_c rtest_i2_r8_d0_tst_c rtest_i4_r8_d0_tst_c rtest_i8_r8_d0_tst_c: \
	FCO := $(RFORT) $(FFLAGSO)
rtest_i2_r8_d1_tst_c rtest_i4_r8_d1_tst_c rtest_i8_r8_d1_tst_c rtest_i2_r8_d0_tst_c rtest_i4_r8_d0_tst_c rtest_i8_r8_d0_tst_c: \
	FCG := $(RFORT) $(FFLAGSG)
rtest_i2_r8_d1_tst_c rtest_i4_r8_d1_tst_c rtest_i8_r8_d1_tst_c rtest_i2_r8_d0_tst_c rtest_i4_r8_d0_tst_c rtest_i8_r8_d0_tst_c: \
	FCF := $(RFORT) $(RFF)

rtest_i2_r16_d1_tst_c rtest_i4_r16_d1_tst_c rtest_i8_r16_d1_tst_c rtest_i2_r16_d0_tst_c rtest_i4_r16_d0_tst_c rtest_i8_r16_d0_tst_c: \
	FCO := $(RFORT) $(FFLAGSO)
rtest_i2_r16_d1_tst_c rtest_i4_r16_d1_tst_c rtest_i8_r16_d1_tst_c rtest_i2_r16_d0_tst_c rtest_i4_r16_d0_tst_c rtest_i8_r16_d0_tst_c: \
	FCG := $(RFORT) $(FFLAGSG)
rtest_i2_r16_d1_tst_c rtest_i4_r16_d1_tst_c rtest_i8_r16_d1_tst_c rtest_i2_r16_d0_tst_c rtest_i4_r16_d0_tst_c rtest_i8_r16_d0_tst_c: \
	FCF := $(RFORT) $(RFF)


# Oracle sunf95
SFORT := "$(shell command -v sunf95)"
ifeq ($(TESTDIM),small)
	SFORT := $(SFORT) -stackvar  # Force all automatic arrays to be on the stack to test whether stack overflow can occur
endif
SFORT := $(SFORT) -w3 -u -U -ansi -xcheck=%all -C
ifeq ($(OSTYPE),LINUX)
	SFORT := $(SFORT) -Wl,-z,noexecstack
endif

stest_i2_r4_d1_tst_c stest_i4_r4_d1_tst_c stest_i8_r4_d1_tst_c stest_i2_r4_d0_tst_c stest_i4_r4_d0_tst_c stest_i8_r4_d0_tst_c: \
	FCO := $(SFORT) $(FFLAGSO) -fnonstd -ftrap=division
stest_i2_r4_d1_tst_c stest_i4_r4_d1_tst_c stest_i8_r4_d1_tst_c stest_i2_r4_d0_tst_c stest_i4_r4_d0_tst_c stest_i8_r4_d0_tst_c: \
	FCG := $(SFORT) $(FFLAGSG) -fnonstd -ftrap=division
stest_i2_r4_d1_tst_c stest_i4_r4_d1_tst_c stest_i8_r4_d1_tst_c stest_i2_r4_d0_tst_c stest_i4_r4_d0_tst_c stest_i8_r4_d0_tst_c: \
	FCF := $(SFORT) $(SFF) -ftrap=division # N.B. -fast implies -ftrap=common; we have to turn off undesired traps manually

stest_i2_r8_d1_tst_c stest_i4_r8_d1_tst_c stest_i8_r8_d1_tst_c stest_i2_r8_d0_tst_c stest_i4_r8_d0_tst_c stest_i8_r8_d0_tst_c: \
	FCO := $(SFORT) $(FFLAGSO) -fnonstd -ftrap=overflow,division#,invalid#,underflow
stest_i2_r8_d1_tst_c stest_i4_r8_d1_tst_c stest_i8_r8_d1_tst_c stest_i2_r8_d0_tst_c stest_i4_r8_d0_tst_c stest_i8_r8_d0_tst_c: \
	FCG := $(SFORT) $(FFLAGSG) -fnonstd -ftrap=overflow,division#,invalid#,underflow
stest_i2_r8_d1_tst_c stest_i4_r8_d1_tst_c stest_i8_r8_d1_tst_c stest_i2_r8_d0_tst_c stest_i4_r8_d0_tst_c stest_i8_r8_d0_tst_c: \
	FCF := $(SFORT) -fnonstd $(SFF) -ftrap=overflow,division

stest_i2_r16_d1_tst_c stest_i4_r16_d1_tst_c stest_i8_r16_d1_tst_c stest_i2_r16_d0_tst_c stest_i4_r16_d0_tst_c stest_i8_r16_d0_tst_c: \
	FCO := $(SFORT) $(FFLAGSO) -fnonstd -ftrap=overflow,division#,invalid#,underflow
stest_i2_r16_d1_tst_c stest_i4_r16_d1_tst_c stest_i8_r16_d1_tst_c stest_i2_r16_d0_tst_c stest_i4_r16_d0_tst_c stest_i8_r16_d0_tst_c: \
	FCG := $(SFORT) $(FFLAGSG) -fnonstd -ftrap=overflow,division#,invalid#,underflow
stest_i2_r16_d1_tst_c stest_i4_r16_d1_tst_c stest_i8_r16_d1_tst_c stest_i2_r16_d0_tst_c stest_i4_r16_d0_tst_c stest_i8_r16_d0_tst_c: \
	FCF := $(SFORT) -fnonstd $(SFF16) -ftrap=overflow,division

# Intel ifx
XFORT := "$(shell command -v ifx)"  #-stand f$(FS)
XFORT := $(XFORT) -warn all -debug full -warn errors -traceback -debug-parameters all #-diag-error-limit 1
# `-auto` causes all local, non-SAVEd variables to be allocated to the run-time stack.
# `-no-heap-arrays`, which is the default for `ifort`, causes the compiler puts automatic arrays
# and temporary arrays in the stack storage area. We enable them for small problems to verify that
# we will not have stack overflows even in the worst case.
# Zaikun 20220323: Not sure how it will work when PRIMA_DEBUGGING is 1, as the debugging facilities
# involve many automatic arrays.
# About -fp-stack-check: According to Steve Lionel (Dr. Fortran), "drop -fp-stack-check - that does
# nothing useful for you (it is for pre-SSE x87 32-bit code.)".
# Zaikun 20250819: Even comparing with quiet NaN may trigger FPE with `ifx -fpe-all=0`.
ifeq ($(TESTDIM),small)
	XFORT := $(XFORT) -auto -no-heap-arrays
else
	XFORT := $(XFORT) -auto -heap-arrays
endif
XFORT := $(XFORT) -standard-semantics -assume recursion
ifeq ($(OSTYPE),LINUX)
	XFORT := $(XFORT) -Wl,-z,noexecstack
endif

# In the following, `-check all,nouninit` can be changed to `-check all` later, probably with OneAPI 2024.1. See
# https://community.intel.com/t5/Intel-Fortran-Compiler/ifx-missing-clang-rt-msan-to-link-Fortran-program-in-debug-build/m-p/1533430
xtest_i2_r4_d1_tst_c xtest_i4_r4_d1_tst_c xtest_i8_r4_d1_tst_c xtest_i2_r4_d0_tst_c xtest_i4_r4_d0_tst_c xtest_i8_r4_d0_tst_c: \
	FCO := $(XFORT) $(FFLAGSO)
xtest_i2_r4_d1_tst_c xtest_i4_r4_d1_tst_c xtest_i8_r4_d1_tst_c xtest_i2_r4_d0_tst_c xtest_i4_r4_d0_tst_c xtest_i8_r4_d0_tst_c: \
	FCG := $(XFORT) $(FFLAGSG) -check all,nouninit
xtest_i2_r4_d1_tst_c xtest_i4_r4_d1_tst_c xtest_i8_r4_d1_tst_c xtest_i2_r4_d0_tst_c xtest_i4_r4_d0_tst_c xtest_i8_r4_d0_tst_c: \
	FCF := $(XFORT) $(XFF)

xtest_i2_r8_d1_tst_c xtest_i4_r8_d1_tst_c xtest_i8_r8_d1_tst_c xtest_i2_r8_d0_tst_c xtest_i4_r8_d0_tst_c xtest_i8_r8_d0_tst_c: \
	FCO := $(XFORT) $(FFLAGSO) -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags
xtest_i2_r8_d1_tst_c xtest_i4_r8_d1_tst_c xtest_i8_r8_d1_tst_c xtest_i2_r8_d0_tst_c xtest_i4_r8_d0_tst_c xtest_i8_r8_d0_tst_c: \
	FCG := $(XFORT) $(FFLAGSG) -check all,nouninit -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags
xtest_i2_r8_d1_tst_c xtest_i4_r8_d1_tst_c xtest_i8_r8_d1_tst_c xtest_i2_r8_d0_tst_c xtest_i4_r8_d0_tst_c xtest_i8_r8_d0_tst_c: \
	FCF := $(XFORT) -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags $(XFF)

xtest_i2_r16_d1_tst_c xtest_i4_r16_d1_tst_c xtest_i8_r16_d1_tst_c xtest_i2_r16_d0_tst_c xtest_i4_r16_d0_tst_c xtest_i8_r16_d0_tst_c: \
	FCO := $(XFORT) $(FFLAGSO) -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags
xtest_i2_r16_d1_tst_c xtest_i4_r16_d1_tst_c xtest_i8_r16_d1_tst_c xtest_i2_r16_d0_tst_c xtest_i4_r16_d0_tst_c xtest_i8_r16_d0_tst_c: \
	FCG := $(XFORT) $(FFLAGSG) -check all,nouninit -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags
xtest_i2_r16_d1_tst_c xtest_i4_r16_d1_tst_c xtest_i8_r16_d1_tst_c xtest_i2_r16_d0_tst_c xtest_i4_r16_d0_tst_c xtest_i8_r16_d0_tst_c: \
	FCF := $(XFORT) -ftrapuv -fpe0 -fpe-all=0 -assume ieee_fpe_flags $(XFF)


# G95
9FORT := "$(shell command -v g95)"
# G95 supports f2003, but not higher.
9FORT := $(9FORT) -std=f2003 -pedantic -Wall -Wextra \
	-Werror=100,113,115,137,146,147,159,163 \
	-Wimplicit-none -Wline-truncation -Wprecision-loss -Wunused-module-vars -Wunused-vars -Wunset-vars \
	-fimplicit-none -fbounds-check -ftrace=full -freal=nan -fmodule-private
ifeq ($(OSTYPE),LINUX)
	9FORT := $(9FORT) -Wl,-z,noexecstack
endif

9test_i2_r4_d1_tst_c 9test_i4_r4_d1_tst_c 9test_i8_r4_d1_tst_c 9test_i2_r4_d0_tst_c 9test_i4_r4_d0_tst_c 9test_i8_r4_d0_tst_c: \
	FCO := $(9FORT) $(FFLAGSO)
9test_i2_r4_d1_tst_c 9test_i4_r4_d1_tst_c 9test_i8_r4_d1_tst_c 9test_i2_r4_d0_tst_c 9test_i4_r4_d0_tst_c 9test_i8_r4_d0_tst_c: \
	FCG := $(9FORT) $(FFLAGSG)
9test_i2_r4_d1_tst_c 9test_i4_r4_d1_tst_c 9test_i8_r4_d1_tst_c 9test_i2_r4_d0_tst_c 9test_i4_r4_d0_tst_c 9test_i8_r4_d0_tst_c: \
	FCF := $(9FORT) $(9FF)

9test_i2_r8_d1_tst_c 9test_i4_r8_d1_tst_c 9test_i8_r8_d1_tst_c 9test_i2_r8_d0_tst_c 9test_i4_r8_d0_tst_c 9test_i8_r8_d0_tst_c: \
	FCO := $(9FORT) $(FFLAGSO)
9test_i2_r8_d1_tst_c 9test_i4_r8_d1_tst_c 9test_i8_r8_d1_tst_c 9test_i2_r8_d0_tst_c 9test_i4_r8_d0_tst_c 9test_i8_r8_d0_tst_c: \
	FCG := $(9FORT) $(FFLAGSG)
9test_i2_r8_d1_tst_c 9test_i4_r8_d1_tst_c 9test_i8_r8_d1_tst_c 9test_i2_r8_d0_tst_c 9test_i4_r8_d0_tst_c 9test_i8_r8_d0_tst_c: \
	FCF := $(9FORT) $(9FF)

9test_i2_r16_d1_tst_c 9test_i4_r16_d1_tst_c 9test_i8_r16_d1_tst_c 9test_i2_r16_d0_tst_c 9test_i4_r16_d0_tst_c 9test_i8_r16_d0_tst_c: \
	FCO := $(9FORT) $(FFLAGSO)
9test_i2_r16_d1_tst_c 9test_i4_r16_d1_tst_c 9test_i8_r16_d1_tst_c 9test_i2_r16_d0_tst_c 9test_i4_r16_d0_tst_c 9test_i8_r16_d0_tst_c: \
	FCG := $(9FORT) $(FFLAGSG)
9test_i2_r16_d1_tst_c 9test_i4_r16_d1_tst_c 9test_i8_r16_d1_tst_c 9test_i2_r16_d0_tst_c 9test_i4_r16_d0_tst_c 9test_i8_r16_d0_tst_c: \
	FCF := $(9FORT) $(9FF)


####################################################################################################
# Add -g to all tests. -g does not conflict with -O in general. See
# https://fortran-lang.discourse.group/t/do-the-g-and-ox-compilation-flags-conflict-with-each-other/
# The following does not work. We have to add -g in the recipe.
#FCG := $(FCG) -g
#FCO := $(FCO) -g
#FCF := $(FCF) -g


####################################################################################################
# All the tests.
# GNU make manual: Recursive make commands should always use the variable MAKE, not the explicit command name ‘make’.
test:
	$(MAKE) $(TESTS)

test_c:
	$(MAKE) $(TESTS_C)

####################################################################################################
# Make a compiler-specific test.
# N.B.:
# 1. Execute CHCKTST by  "bash $(CHCKTST)" instead of just "$(CHCKTST)", because "$(CHCKTST)" may
# not be executable on all operating systems.
# 2. The log for itest or itest_i2 will be itest_(STAMP). Similar for other tests.
# 3. In the following, `@$(MAKE) $(TST_C)` will trigger `@$(MAKE) $(SUBTESTS_C)`, which compile the code
# for all subtests. Then `@$(MAKE) $(SUBTESTS)` will test the binaries. We not test any binary until
# the code can compile in all cases.
$(TESTS) $(TESTS_INT):
	@mkdir -p $(LOG_DIR)
	@printf "\n$@ starts.\n\n" | tee -a "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*//").log"
	@$(MAKE) $(TST_C)
	@$(MAKE) $(SUBTESTS) --jobs $(NPROCS)
	@bash $(CHCKTST) --error "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*//").log"
	@bash $(CHCKTST) --warning "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*//").log"
	@printf "\n\n$@ ends!\n\n" | tee -a "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*//").log"
	@mv "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*//").log" "$(LOG_DIR)/$@_$(STAMP).log"
	@$(MAKE) clean

# Make the binary corresponding to a test in TESTS_C or TESTS_INT_C, but do not execute it.
# This is useful if we want to check whether the code can compile.
$(TESTS_C) $(TESTS_INT_C):
	@mkdir -p $(LOG_DIR)
	@printf "\n$@ starts.\n\n" | tee -a "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*/_c/").log"
	@$(MAKE) $(SUBTESTS_C)
	@bash $(CHCKTST) --error "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*/_c/").log"
	@bash $(CHCKTST) --warning "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*/_c/").log"
	@printf "\n\n$@ ends!\n\n" | tee -a "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*/_c/").log"
	@mv "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*/_c/").log" "$(LOG_DIR)/$@_$(STAMP).log"
	@$(MAKE) cleanmisc

# Make a compiler-specific subtest.
# N.B.:
# 1. The prerequisite should NOT include files that may not exist, e.g., $(SRC), because
# Make will ignore the rule if such files do not exist, resulting in "No rule to make ..." mistake.
# 2. `set -eu -o pipefail` instructs Bash to fail immediately and loudly when anything goes wrong
# in the piped commands.
# 3. The calls to `execstack` are for debugging, to check whether executable stack exists when
# `Wl,-z,noexecstack` is removed from the compiler options.
#%_tst: %_tst_c
%_tst:
	@if [[ ! -f $@_c ]] ; then \
		$(MAKE) $@_c ; \
	else \
		printf "\n$@_c exists!\n\n" ; \
	fi
	@mkdir -p $(LOG_DIR)
	@echo 0 > "$(LOG_DIR)/$@.GDB_EXIT_CODE"  # Initialize the GDB exit code file, because GDB may not be executed (e.g., test is skipped or on Mac)
	@if echo $@ | grep -q "9test" ; then \
		printf "\n$@ is skipped!\n\n" | tee -a "$(LOG_DIR)/$@.log" ; \
	elif echo $@ | grep -q "_d0" && [[ $(TESTDIM) = "big" ]] ; then \
		printf "\n$@ is skipped since we are testing a BIG problem!\n\n" | tee -a "$(LOG_DIR)/$@.log" ; \
	else  \
		if [[ -n "$(FFLAGSO)" ]] ; then \
			if [[ -x $@_c_$(SUFFIXO) ]] ; then \
				if command -v execstack >/dev/null 2>&1 ; then \
					printf "\n===> Check executable stack: " && execstack -q $@_c_$(SUFFIXO) && \
					printf "===> Clear executable stack: " && execstack -c $@_c_$(SUFFIXO) && \
					printf "\n===> Check executable stack again: " && execstack -q $@_c_$(SUFFIXO) \
					| tee -a "$(LOG_DIR)/$@.log" ; \
				fi ; \
				export NVCOMPILER_TERM=trace && set -eu -o pipefail && \
				printf "\n$@_$(SUFFIXO) starts.\n\n" | tee -a "$(LOG_DIR)/$@.log" && \
				$(GDB) ./$@_c_$(SUFFIXO) $(LOG_DIR)/$@.GDB_EXIT_CODE 2>&1 \
				| grep -v "Processor does not support trapping of floating-point exceptions" \
				| grep -v "libthread_db" \
				| tee -a "$(LOG_DIR)/$@.log" ; \
			else \
				printf "\n$@_c_$(SUFFIXO) is not executable!\n\n" | tee -a "$(LOG_DIR)/$@.log" ; \
				exit 126 ; \
			fi ; \
		fi ; \
		if [[ -n "$(FFLAGSG)" ]] ; then \
			if [[ -x $@_c_$(SUFFIXG) ]] ; then \
				if command -v execstack >/dev/null 2>&1 ; then \
					printf "\n===> Check executable stack: " && execstack -q $@_c_$(SUFFIXG) && \
					printf "===> Clear executable stack: " && execstack -c $@_c_$(SUFFIXG) && \
					printf "\n===> Check executable stack again: " && execstack -q $@_c_$(SUFFIXG) \
					| tee -a "$(LOG_DIR)/$@.log" ; \
				fi ; \
				export NVCOMPILER_TERM=trace && set -eu -o pipefail && \
				printf "\n$@_$(SUFFIXG) starts.\n\n" | tee -a "$(LOG_DIR)/$@.log" && \
				$(GDB) ./$@_c_$(SUFFIXG) $(LOG_DIR)/$@.GDB_EXIT_CODE 2>&1 \
				| grep -v "Processor does not support trapping of floating-point exceptions" \
				| grep -v "libthread_db" \
				| tee -a "$(LOG_DIR)/$@.log" ; \
			else \
				printf "\n$@_c_$(SUFFIXG) is not executable!\n\n" | tee -a "$(LOG_DIR)/$@.log" ; \
				exit 126 ; \
			fi ; \
		fi ; \
	fi
	@set +o pipefail  # Restore the original pipe setting
	@bash $(CHCKTST) --error "$(LOG_DIR)/$@.log"
	@bash $(CHCKTST) --warning "$(LOG_DIR)/$@.log"
	@echo "gdb exit code was: " && cat "$(LOG_DIR)/$@.GDB_EXIT_CODE" && exit $$(cat "$(LOG_DIR)/$@.GDB_EXIT_CODE")
	@printf "$@ ends at $(shell date +%Y.%m.%d_%H.%M.%S).\n" | tee -a "$(LOG_DIR)/$@.log"
	@cat "$(LOG_DIR)/$@.log" >> "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*//").log"
	@rm "$(LOG_DIR)/$@.log" || :
	@rm "$(LOG_DIR)/$@.GDB_EXIT_CODE" || :
	@$(MAKE) cleanmisc

# Make the binary corresponding to %_tst_c, but do not execute it.
# This is useful if we want to check whether the code can compile.
%_tst_c: source_%
	@mkdir -p $(LOG_DIR)
	@printf "\n$@ starts.\n\n" | tee -a "$(LOG_DIR)/$@.log"
	$(eval DBG := $(shell echo $@ | sed "s/.*_d//" | sed "s/_.*//"))
	$(eval IK := $(shell expr 8 \* $$(echo $@ | sed "s/.*_i//" | sed "s/_.*//")))
	$(eval RP := $(shell expr 8 \* $$(echo $@ | sed "s/.*_r//" | sed "s/_.*//")))
	$(eval QPAVLB := $(shell expr $$(echo $@ | sed "s/.*_r//" | sed "s/_.*//") / 16))
	$(eval EXTRA_FLAGS := -g -DPRIMA_DEBUGGING=$(DBG) -DPRIMA_AGGRESSIVE_OPTIONS=$(AGGRESSIVE) \
		-DPRIMA_INTEGER_KIND=$(IK) -DPRIMA_REAL_PRECISION=$(RP) -DPRIMA_QP_AVAILABLE=$(QPAVLB) -DPRIMA_TESTDIM=\"'$(TESTDIM)'\")
	$(eval EXTRA_FLAGS := $(shell if [[ -z "$(TESTSEED)" ]] ; then echo "$(EXTRA_FLAGS)"; else echo "$(EXTRA_FLAGS) -DPRIMA_TESTSEED=$(TESTSEED)"; fi))
	$(eval SRC := $(shell if echo $@ | grep -q "9test"; then echo $(SRC_NO_TEST) ; else echo $(SRC) ; fi))
	$(eval FC := $(shell cut -d' ' -f1 <<< "$(FCO)"))
	@echo "=====> OSTYPE = " $(OSTYPE)
	@echo "Compiler: $(FC)"
	@$(FC) --version 2>&1 | grep -v "\-\-version\|usage" || true  # Print the compiler version, but do not fail if the compiler does not support `--version`
	@echo ""
	(if echo $@ | grep -q '9test'; then \
		if [[ -n '$(FFLAGSO)' ]] ; then \
			if [[ '$(FFLAGSO)' = '-fast' ]] ; then \
				$(FCF) $(EXTRA_FLAGS) -c $(SRC) ; \
			else \
				$(FCO) $(EXTRA_FLAGS) -c $(SRC) ; \
			fi ; \
		fi ; \
		if [[ -n '$(FFLAGSG)' ]] ; then \
			$(FCG) $(EXTRA_FLAGS) -c $(SRC) ; \
		fi ; \
	else \
		if echo $@ | grep -q 'itest\|xtest' && [[ '$(OSTYPE)' = 'MAC' || '$(OSTYPE)' = 'LINUX' ]] ; then \
			printf "Initialize Intel OneAPI." ; \
			source /opt/intel/oneapi/setvars.sh 2> /dev/null ; \
		fi ; \
		if [[ -n '$(FFLAGSO)' ]] ; then \
			if [[ '$(FFLAGSO)' = '-fast' ]] ; then \
				$(FCF) $(EXTRA_FLAGS) -o $@_$(SUFFIXO) $(SRC) ; \
			else \
				$(FCO) $(EXTRA_FLAGS) -o $@_$(SUFFIXO) $(SRC) ; \
			fi ; \
		fi ; \
		if [[ -n '$(FFLAGSG)' ]] ; then \
			$(FCG) $(EXTRA_FLAGS) -o $@_$(SUFFIXG) $(SRC) ; \
		fi ; \
	fi) 2>&1 \
	| grep -v "^[[:blank:]]*$$" \
	| grep -v "Using 'dlopen' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking" \
	| grep -v "ld: warning: no platform load command found in.*assuming: macOS" \
	| grep -v "/usr/bin/ld: warning: libpgmath.so.0d, needed by .*libflang.so, not found" \
	| grep -v "Warning (165): Implicit interface 'calfun' called at (1)" \
	| grep -v "Warning (165): Implicit interface 'calcfc' called at (1)" \
	| grep -v "Warning (165): Implicit interface 'callback_fcn' called at (1)" \
	| grep -v "Warning (102): MODULE PROCEDURE 'inv' USEd at (1) is not referenced" \
	| grep -v "Warning (102): MODULE PROCEDURE 'calfun' USEd at (1) is not referenced" \
	| grep -v "Warning (102): MODULE PROCEDURE 'calcfc' USEd at (1) is not referenced" \
	| grep -v "Warning (102): MODULE PROCEDURE 'redrat' USEd at (1) is not referenced" \
	| grep -v "Warning (102): MODULE PROCEDURE 'redrho' USEd at (1) is not referenced" \
	| grep -v "common/linalg.f90:[0-9]*:.*pivot.*may be used uninitialized" \
	| grep -v "common/linalg.f90:[0-9]*:.*rank.*may be used uninitialized" \
	| grep -v "common/preproc.f90:[0-9]*:.*min_maxfun.*may be used uninitialized" \
	| grep -v "common/preproc.f90:[0-9]*:.*unit_memo.*may be used uninitialized" \
	| grep -v "Compiling file\|Module subprogram name" \
	| grep -v "An allocatable array function '.*' is an extended feature" \
	| grep -v "An allocatable dummy array '.*' is an extended feature" \
	| grep -v "WARNING --  When --chk x is specified, it must be used to compile all source files of a program" \
	| grep -v "0 Errors, 0 Warnings" \
	| grep -v "Encountered 0 errors, 0 warnings, [0-9]* information.* in file" \
	| grep -v "after the END INTERFACE keywords is only legal in Fortran 95 and beyond" \
	| grep -v "Extension.*Stop-code is not constant" \
	| grep -v "Option warning: Due to MacOS/Silicon limitations, this may not work reliably" \
	| grep -v "NAG Fortran Compiler Release [0-9]*.* Build [0-9]*" \
	| grep -v "Questionable: ./lincoa/geometry.f90, line [0-9]*: Variable RSTAT set but never referenced" \
	| grep -v "Expression in IF construct is constant" \
	| grep -v "NAG Fortran Compiler normal termination" \
	| grep -v "NAG Fortran Compiler normal termination, [0-9]* info message" \
	| grep -v "Info: No licences currently available for product" \
	| grep -v "Info: Licence received, continuing" \
	| grep -v "Loading..." \
	| grep -v "Linking:" \
	| grep -v "function circle_maxabs(fun, args, grid_size) result(angle)" \
	| grep -v "function circle_min(fun, args, grid_size) result(angle)" \
	| grep -v "univar\.f90([0-9]*): remark #7712: This variable has not been used\.\s*\[ANGLE\]" \
	| grep -v "f90comp: [0-9]* SOURCE LINES" \
	| grep -v "f90comp: [0-9]* ERRORS, [0-9]* WARNINGS" \
	| grep -v "ANSI: PROCEDURE is a Fortran 2003 feature" \
	| grep -v "Fortran requires all intrinsic procedure actual arguments to be type integer or character for restricted expressions" \
	| grep -v "Fortran 90 requires all intrinsic procedure actual arguments to be type integer or character for restricted expressions" \
	| grep -v "Intrinsics which return a data type other than integer are not allowed in specification expressions" \
	| grep -v "remark #5415: Feature not yet implemented" \
	| grep -v "interpolation error" \
	| grep -v "In file ./common/evaluate.f90:134" \
	| grep -v "In file ./common/evaluate.f90:201" \
	| grep -v "./common/linalg.f90: In function ‘linalg_mod_MP_lsqr’:" \
	| grep -v "./common/preproc.f90: In function ‘preproc_mod_MP_preproc’:" \
	| grep -v "WARNING --  When --chk x is specified" \
	| grep -v "bin/ld.*bisheng.*unsupported GNU_PROPERTY_TYPE (5) type: 0xc0000000" \
	| grep -v "This intrinsic function in a specification expression is not standard Fortran 95\.\s*\[SQRT\]" \
	| grep -v "This intrinsic function in a specification expression is not standard Fortran 95\.\s*\[NINT\]" \
	| grep -v "f90: Warning: -xcache=native detection failed, falling back to -xcache=generic" \
	| grep -v "warning: line table parameters mismatch. Cannot emit." \
	| grep -v "note: while processing /var/folders/" \
	| grep -v "all warnings being treated as errors" \
	| grep -v "warning: (x86_64)  could not find object file symbol for symbol ___mulvdi3" \
	| grep -v "warning: (x86_64)  could not find object file symbol for symbol ___mulvsi3" \
	| grep -v "warning: (x86_64)  could not find object file symbol for symbol ___negvdi2" \
	| grep -v "warning: (x86_64)  could not find object file symbol for symbol ___negvsi2" \
	| grep -v "warning: (x86_64)  could not find object file symbol for symbol ___powidf2" \
	| grep -v "warning: (x86_64)  could not find object file symbol for symbol ___powisf2" \
	| grep -v "warning: (x86_64)  could not find object file symbol for symbol ___subvdi3" \
	| grep -v "warning: (x86_64)  could not find object file symbol for symbol ___subvsi3" \
	| grep -v "cos_seed.dim\[0\].ubound.* may be used uninitialized" \
	| grep -v "\.testdim_loc.* may be used uninitialized" \
	| grep -v "\.min_maxfun_str.* may be used uninitialized" \
	| grep -v "\.direction_loc.* may be used uninitialized" \
	| grep -v "\.msg.* may be used uninitialized" \
	| grep -v "\.reason.* may be used uninitialized" \
	| grep -v "\.fname.* may be used uninitialized" \
	| grep -v "\.fstat.* may be used uninitialized" \
	| grep -v "\..*_message.* may be used uninitialized" \
	| grep -v "\.message.* may be used uninitialized" \
	| grep -v "\.fname_loc.* may be used uninitialized" \
	| grep -v "\.position.* may be used uninitialized" \
	| grep -v "\.sformat.* may be used uninitialized" \
	| grep -v "\.noise_type_loc.* may be used uninitialized" \
	| grep -v "ld: warning: -keep_dwarf_unwind is obsolete" \
	| grep -v "ld: warning: ignoring duplicate libraries:.*libsvml.a" \
	| grep -v "ipo: warning #11021: unresolved __ehdr_start" \
	| grep -v "\[-Wgcc-install-dir-libstdcxx\]" \
	| grep -v "ld: warning: ignoring duplicate libraries: '-lSystem'" \
	| grep -v "ld: warning: reexported library with install name" \
	| grep -v "warning: argument unused during compilation" \
	| tee -a "$(LOG_DIR)/$@.log"
	@bash $(CHCKTST) --error "$(LOG_DIR)/$@.log"
	@bash $(CHCKTST) --warning "$(LOG_DIR)/$@.log"
	@printf "$@ ends at $(shell date +%Y.%m.%d_%H.%M.%S).\n" | tee -a "$(LOG_DIR)/$@.log"
	@cat "$(LOG_DIR)/$@.log" >> "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*/_c/").log"
	@rm "$(LOG_DIR)/$@.log" || :
	@$(MAKE) cleanmisc
	@touch $@
# Without the last line, 9test_c is always remade when making 9test even if 9test_c is up
# to date. Also observed for gtest on Windows. No idea why. Strange! Better approach?
# Note that %test is made in parallel. If %test_c is remade when making %test, then it will also
# be in parallel, which will cause errors.

# Make a local copy of the source code for the test.
source_%: $(SRC_DIRS)
	@printf "\nMaking a copy of the source code for the test.\n"
	@for DIR in $(SRC_DIRS); do cp -r "$$DIR" ./; done
	@for SRC in $(DRIVER_SRC); do cp $(DRIVER_DIR)/"$$SRC" ./; done
	@find ./ \( \
		-name "*.mod" \
		-o -name "*.o" \
		-o -name "*.dbg" \
		-o -name "*.cmdx" \
		-o -name "*.cmod" \
		-o -name "*.ilm" \
		-o -name "*.stb" \
		-o -name "*.out" \
		-o -name "*__genmod.f90" \
		-o -name "flint" \
		-o -name "mlint" \
		\) -exec rm {} \;  # Cleaning up; important!!!
	# Huawei Bisheng Flang 2.1.0 and AOCC 5.1 Flang are buggy concerning 0-dimensional arrays, and
	# they report false positive out-bound indices. Thus preprocessing by dsrc is needed. See
	# https://github.com/flang-compiler/flang/issues/1238
	# Check it again when new versions are available. Make a test using
	# https://github.com/zequipe/test_compiler/blob/master/test_solve.f90
	@printf "\nPreparing the source code for $@.\n"
	@if echo $@ | grep -q "gtest" && echo $(FFLAGS) | grep -q "fast"; then \
		bash $(TOOLS_DIR)/gsrc ./ ; \
	fi
	@if echo $@ | grep -q "ftest\|mtest\|rtest"; then \
		bash $(TOOLS_DIR)/flsrc ./ ; \
	fi
	@if echo $@ | grep -q "vtest" && echo $(FFLAGS) | grep -q "fast"; then \
		bash $(TOOLS_DIR)/vsrc ./ ; \
	fi
	@if echo $@ | grep -q "dtest"; then \
		bash $(TOOLS_DIR)/dsrc ./ ; \
	fi
	@if echo $@ | grep -q "stest"; then \
		bash $(TOOLS_DIR)/sunsrc ./ ; \
	fi
	@if echo $@ | grep -q "9test"; then \
		bash $(TOOLS_DIR)/9src ./ ; \
	fi
	@printf "Done.\n"

# Adapt the header file for the test.
# Zaikun 20230411: Instead of modifying the header file, we should use the -D option of the
# preprocessors (cpp or fpp). See the definition of $(EXTRA_FLAGS) for details.
#header_%: IK = $(shell expr 8 \* $$(echo $@ | sed "s/.*_i//" | sed "s/_.*//"))
#header_%: RP = $(shell expr 8 \* $$(echo $@ | sed "s/.*_r//" | sed "s/_.*//"))
#header_%: DBG = $(shell echo $@ | sed "s/.*_d//" | sed "s/_.*//")
#header_%: QPAVLB = $(shell expr $$(echo $@ | sed "s/.*_r//" | sed "s/_.*//") / 16)
#header_%: source_%
#	@printf "\nPreparing the header file for the test.\n"
#	$(SEDI) "s|^#define PRIMA_QP_AVAILABLE [0-9]*|#define PRIMA_QP_AVAILABLE $(QPAVLB)|" $(HEADERS)
#	$(SEDI) "s|^#define PRIMA_INTEGER_KIND [0-9]*|#define PRIMA_INTEGER_KIND $(IK)|" $(HEADERS)
#	$(SEDI) "s|^#define PRIMA_REAL_PRECISION [0-9]*|#define PRIMA_REAL_PRECISION $(RP)|" $(HEADERS)
#	$(SEDI) "s|^#define PRIMA_DEBUGGING [0-9]*|#define PRIMA_DEBUGGING $(DBG)|" $(HEADERS)
#	$(SEDI) "s|^#define PRIMA_AGGRESSIVE_OPTIONS [0-9]*|#define PRIMA_AGGRESSIVE_OPTIONS $(AGGRESSIVE)|" $(HEADERS)
#	@printf "Done.\n"


####################################################################################################
# Cleaning up.
# ":" means to do nothing in bash. We can use "COMMAND || :" to avoid errors when COMMAND fails.
cleanbin:
	@printf "\nCleaning up the binaries ...\n"
	@rm -f *_tst_c || :
	@rm -f *_test_c || :
	@printf "Done.\n"

cleanmisc:
	@printf "\nCleaning up miscellaneous files ...\n"
	@rm -f *.o *.mod *.dbg *.cmdx *.cmod *.ilm *.stb *.out *__genmod.f90 || :
	@rm -f *_output.txt || :
	@printf "Done.\n"

cleansrc:
	@printf "\nCleaning up the source code ...\n"
	@for ITEM in $(COMMON) $(SOLVER) $(TESTSUITE) $(DRIVER_SRC) ; do  \
		if [ `ls -1 "$$ITEM" 2>/dev/null | wc -l ` -gt 0 ] ; \
			then mkdir -p $(TRASH_DIR) && rm -rf $(TRASH_DIR)/"$$ITEM" || : ; \
			mv "$$ITEM" $(TRASH_DIR) > /dev/null 2>&1 || : ; \
		fi ; \
	done
	@printf "Done.\n"

clean: cleanbin cleanmisc cleansrc

cleanall: clean
	@printf "\nRemoving the contents of $(TEST_SOLVER_DIR) ...\n"
	@rm -rf $(TEST_SOLVER_DIR)/* &> /dev/null || :
	@printf "Done.\n"
